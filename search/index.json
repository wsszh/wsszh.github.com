[{"content":"通过在scollector的配置文件中进行配置，就可以让scollector收集你需要的进程的相关数据\n监控进程 配置项  Command：指定可执行程序的路径，如\u0026quot;/bin/java\u0026quot;，可以用正则表达式匹配；也可以直接是某个可执行程序的名称（应该是路径已经存在于环境变量中了） Name：用作linux.proc.*和os.proc.*这些metric中name这个tag对应的value，在Bosun的Graph页面，通过指定tag = Name，就可以查询Command对应进程（一个或者多个）的一系列数据，包括：  linux.proc.char_io\rlinux.proc.cpu\rlinux.proc.io_bytes\rlinux.proc.mem.fault\rlinux.proc.mem.rss\rlinux.proc.mem.virtual\rlinux.proc.num_fds\rlinux.proc.num_fds_hlim\rlinux.proc.num_fds_slim\rlinux.proc.start_time\rlinux.proc.syscall\rlinux.proc.uptime\rlinux.processes\rlinux.procs_blocked\r Args：可选项，可以用正则表达式从Command对应的多个进程中选出某个特定的进程（比如从多个java进程中，选出tomcat对应的进程），当Command对应多个进程，又没有用Args筛选出某个特定进程时，系统会给每个进程分配一个id，从1开始递增，作为id这个tag的value，可以在Bosun的Graph页面，通过指定tag = Name和id = n（n为进程分配到的id的值），查询Command对应的某个特定进程的值（个人觉得这没啥意义，搞不清id = 1, 2, 3\u0026hellip;分别是哪个进程，所以还是配置Args参数比较好，参数值可以是进程对应的arguments的全部或者一部分，最后的注意点会提到） IncludeCount：可选项，不配置的话，默认是false，linux.proc.count这个metric也不会被创建，但一旦配置为true，系统就会创建出linux.proc.count这个metric作为进程计数器，我们可以查询linux.proc.count tag=Name对应的进程数量（Name就是第一个配置项Name的值）  监控Command参数对应的所有进程 在scollector的配置文件中添加：\n[[Process]] Command = \u0026#34;/bin/java\u0026#34; Name = \u0026#34;java\u0026#34; 这样就可以让scollector收集所有java进程的数据\n监控Commad参数对应的某一个进程 在scollector的配置文件中添加：\n[[Process]] Command = \u0026#34;/bin/java\u0026#34; Name = \u0026#34;tomcat\u0026#34; Args = \u0026#34;tomcat\u0026#34; Args这个参数可以理解为查询条件，筛选出某个特定的进程，这个就是从java进程中选出了tomcat对应的进程\n监控Commad参数对应的进程的个数 [[Process]] Command = \u0026#34;/bin/java\u0026#34; Name = \u0026#34;java\u0026#34; IncludeCount = true 这样就可以实时监控java进程的个数\n监控Systemd Services scollector通过D-Bus API判断systemd services（不知道怎么翻译比较好，反正就是在centos中可以通过systemctl命令管理和查看的那些服务单元）的状态，我们也可以通过修改配置文件对它们进行监控\n配置项  Name：一个正则表达式，匹配服务单元的名称（可以一次匹配多个），被匹配到的名称作为linux.systemd.unit.*和os.service.*这些metric中name这个tag对应的value WatchProc：可选项，默认false，如果配置为true，服务单元的名称也会作为linux.proc.*和os.proc.*这些metric中name这个tag对应的value，scollector就开始收集服务单元对应以下metric的数据：  linux.proc.char_io\rlinux.proc.cpu\rlinux.proc.io_bytes\rlinux.proc.mem.fault\rlinux.proc.mem.rss\rlinux.proc.mem.virtual\rlinux.proc.num_fds\rlinux.proc.num_fds_hlim\rlinux.proc.num_fds_slim\rlinux.proc.start_time\rlinux.proc.syscall\rlinux.proc.uptime\rlinux.processes\rlinux.procs_blocked\r举个例子 我在系统中安装了docker，可以用命令查看状态：\nsystemctl status docker\r然后修改配置文件：\n[[SystemdService]] Name = \u0026#34;^docker$\u0026#34; WatchProc = true 这里WatchProc设置为true，不仅可以查询docker对应linux.systemd.unit.*这些metric的数据，还可以查询docker对应linux.proc.*和os.proc.*这些metric的数据\n注意点  在配置要监控的进程前，可以通过命令查看当前所有处于运行状态的进程以及它们的参数：  ps -ef\r  根据官方文档的说明，scollector是通过读取文件/proc/pid/cmdline（进程的PID）来区分进程对应的command和arguments，默认是以0x00作为分隔符，第一个分隔符前的是command，第一个分隔符后的是一系列用分隔符隔开的arguments\n  有些进程修改了/proc/pid/cmdline中的内容，如官网举的例子：\n  cat /proc/80156/cmdline | hexdump -C\r00000000 2f 75 73 72 2f 62 69 6e 2f 72 65 64 69 73 2d 73 |/usr/bin/redis-s|\r00000010 65 72 76 65 72 20 2a 3a 36 33 37 39 00 00 00 00 |erver *:6379....|\r00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\r00000030 00 |.|\r00000031\r#Example for cmdline without NUL (00) delimiters between args (using \\ to escape * in regex)\r[[Process]]\rCommand = 'redis-server \\*:6379'\rName = \u0026quot;redis-core\u0026quot;\r这个例子中，/usr/bin/redis-server是command，*:6379是arguments，但两者之间是以0x20作为分隔符的，所以要修改Command配置项的写法（注意要用单引号），\\*:6379可以让scollector在读取cmdline文件时，忽略*:6379，避免将其作为command的一部分\n 配置项Args可以只是进程对应arguments的一部分，只要能确保作为该进程的筛选条件即可，比如tomcat进程的PID为13665，查看对应的cmdline文件：  cat /proc/13665/cmdline | hexdump -C'\r00000000 2f 75 73 72 2f 6a 61 76 61 2f 6a 64 6b 31 2e 38 |/usr/java/jdk1.8|\r00000010 2e 30 5f 31 31 31 2f 62 69 6e 2f 6a 61 76 61 00 |.0_111/bin/java.|\r00000020 2d 44 6a 61 76 61 2e 75 74 69 6c 2e 6c 6f 67 67 |-Djava.util.logg|\r00000030 69 6e 67 2e 63 6f 6e 66 69 67 2e 66 69 6c 65 3d |ing.config.file=|\r00000040 2f 72 6f 6f 74 2f 6c 6f 63 61 6c 2f 61 70 61 63 |/root/local/apac|\r00000050 68 65 2d 74 6f 6d 63 61 74 2d 38 2e 35 2e 38 2f |he-tomcat-8.5.8/|\r00000060 63 6f 6e 66 2f 6c 6f 67 67 69 6e 67 2e 70 72 6f |conf/logging.pro|\r00000070 70 65 72 74 69 65 73 00 2d 44 6a 61 76 61 2e 75 |perties.-Djava.u|\r00000080 74 69 6c 2e 6c 6f 67 67 69 6e 67 2e 6d 61 6e 61 |til.logging.mana|\r00000090 67 65 72 3d 6f 72 67 2e 61 70 61 63 68 65 2e 6a |ger=org.apache.j|\r000000a0 75 6c 69 2e 43 6c 61 73 73 4c 6f 61 64 65 72 4c |uli.ClassLoaderL|\r000000b0 6f 67 4d 61 6e 61 67 65 72 00 2d 44 6a 64 6b 2e |ogManager.-Djdk.|\r000000c0 74 6c 73 2e 65 70 68 65 6d 65 72 61 6c 44 48 4b |tls.ephemeralDHK|\r000000d0 65 79 53 69 7a 65 3d 32 30 34 38 00 2d 44 6a 61 |eySize=2048.-Dja|\r000000e0 76 61 2e 70 72 6f 74 6f 63 6f 6c 2e 68 61 6e 64 |va.protocol.hand|\r000000f0 6c 65 72 2e 70 6b 67 73 3d 6f 72 67 2e 61 70 61 |ler.pkgs=org.apa|\r00000100 63 68 65 2e 63 61 74 61 6c 69 6e 61 2e 77 65 62 |che.catalina.web|\r00000110 72 65 73 6f 75 72 63 65 73 00 2d 63 6c 61 73 73 |resources.-class|\r00000120 70 61 74 68 00 2f 72 6f 6f 74 2f 6c 6f 63 61 6c |path./root/local|\r00000130 2f 61 70 61 63 68 65 2d 74 6f 6d 63 61 74 2d 38 |/apache-tomcat-8|\r00000140 2e 35 2e 38 2f 62 69 6e 2f 62 6f 6f 74 73 74 72 |.5.8/bin/bootstr|\r00000150 61 70 2e 6a 61 72 3a 2f 72 6f 6f 74 2f 6c 6f 63 |ap.jar:/root/loc|\r00000160 61 6c 2f 61 70 61 63 68 65 2d 74 6f 6d 63 61 74 |al/apache-tomcat|\r00000170 2d 38 2e 35 2e 38 2f 62 69 6e 2f 74 6f 6d 63 61 |-8.5.8/bin/tomca|\r00000180 74 2d 6a 75 6c 69 2e 6a 61 72 00 2d 44 63 61 74 |t-juli.jar.-Dcat|\r00000190 61 6c 69 6e 61 2e 62 61 73 65 3d 2f 72 6f 6f 74 |alina.base=/root|\r000001a0 2f 6c 6f 63 61 6c 2f 61 70 61 63 68 65 2d 74 6f |/local/apache-to|\r000001b0 6d 63 61 74 2d 38 2e 35 2e 38 00 2d 44 63 61 74 |mcat-8.5.8.-Dcat|\r000001c0 61 6c 69 6e 61 2e 68 6f 6d 65 3d 2f 72 6f 6f 74 |alina.home=/root|\r000001d0 2f 6c 6f 63 61 6c 2f 61 70 61 63 68 65 2d 74 6f |/local/apache-to|\r000001e0 6d 63 61 74 2d 38 2e 35 2e 38 00 2d 44 6a 61 76 |mcat-8.5.8.-Djav|\r000001f0 61 2e 69 6f 2e 74 6d 70 64 69 72 3d 2f 72 6f 6f |a.io.tmpdir=/roo|\r00000200 74 2f 6c 6f 63 61 6c 2f 61 70 61 63 68 65 2d 74 |t/local/apache-t|\r00000210 6f 6d 63 61 74 2d 38 2e 35 2e 38 2f 74 65 6d 70 |omcat-8.5.8/temp|\r00000220 00 6f 72 67 2e 61 70 61 63 68 65 2e 63 61 74 61 |.org.apache.cata|\r00000230 6c 69 6e 61 2e 73 74 61 72 74 75 70 2e 42 6f 6f |lina.startup.Boo|\r00000240 74 73 74 72 61 70 00 73 74 61 72 74 00 |tstrap.start.|\r0000024d\r不同于官方文档举的那个例子，这里还是以0x00作为分隔符的，我们可以看到，第一个分隔符位于第二行的最后一个字节，在其前面的就是tomcat进程的command：/usr/java/jdk1.8.0_111/bin/java，在其后面的就是一大串arguments\n然后我们用命令查看当前处于运行状态并且arguments中带有tomcat的进程：\nps -ef | grep tomcat\r发现只有tomcat这一个进程，所以我们在上面的操作中仅仅将配置项指定为Args = \u0026quot;tomcat\u0026quot;是可以放心的，已经足够精确地筛选出tomcat这个进程了，否则的话我们就要考虑从tomcat进程的arguments中选取更多部分赋值给配置项Args，以保证筛选结果的唯一性\n","date":"2016-12-02T17:06:44+08:00","permalink":"https://sgouz.com/p/%E7%94%A8scollector%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B/","title":"用scollector监控进程"},{"content":"博客终于搭建的差不多了，种一棵树最好的时间就是现在，希望日后能伴我成长，我尽量能记录下一些有意义的文字，不求多，贵在精。\n","date":"2016-10-19T00:17:00+08:00","permalink":"https://sgouz.com/p/%E7%A7%8D%E4%B8%8B%E4%B8%80%E6%A3%B5%E6%A0%91/","title":"种下一棵树"}]